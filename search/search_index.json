{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"yaml12 \u00b6 A YAML 1.2 parser/formatter for Python, implemented in Rust for speed and correctness. Built on the excellent saphyr crate. For almost every use case, yaml12 lets you work with plain builtin Python types end to end: dict , list , int , float , str , and None . Parse YAML text or files with parse_yaml() and read_yaml() . Serialize Python values with format_yaml() or write_yaml() . 100% compliance with the yaml-test-suite . Advanced YAML features (document streams, tags, complex mapping keys) are supported and round-trip cleanly when needed; see the advanced guide if needed. Installation \u00b6 The project targets Python 3.10+ and builds via maturin (Rust toolchain required). From the repository root: python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -e . --no-build-isolation Quick start \u00b6 from yaml12 import parse_yaml, format_yaml yaml_text = \"\"\" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] features: tags: preserve streams: multi \"\"\" doc = parse_yaml(yaml_text) assert doc == { \"title\": \"A modern YAML parser and emitter written in Rust\", \"properties\": [\"fast\", \"correct\", \"safe\", \"simple\"], \"features\": {\"tags\": \"preserve\", \"streams\": \"multi\"}, } text = format_yaml(doc) print(text) # title: A modern YAML parser and emitter written in Rust # properties: # - fast # - correct # - safe # - simple # features: # tags: preserve # streams: multi Reading and writing files \u00b6 from yaml12 import read_yaml, write_yaml value_out = {\"alpha\": 1, \"nested\": [True, None]} write_yaml(value_out, \"my.yaml\") value_in = read_yaml(\"my.yaml\") assert value_in == value_out # Multi-document streams docs_out = [{\"foo\": 1}, {\"bar\": [2, None]}] write_yaml(docs_out, \"my-multi.yaml\", multi=True) docs_in = read_yaml(\"my-multi.yaml\", multi=True) assert docs_in == docs_out Tag handlers \u00b6 Handlers let you opt into custom behaviour for tagged nodes while keeping the default parser strict and safe. from yaml12 import parse_yaml yaml_text = \"\"\" - !upper [rust, python] - !expr 6 * 7 \"\"\" handlers = { \"!expr\": lambda value: eval(value), \"!upper\": lambda value: [x.upper() for x in value], } doc = parse_yaml(yaml_text, handlers=handlers) assert doc == [[\"RUST\", \"PYTHON\"], 42] Formatting and round-tripping \u00b6 from yaml12 import format_yaml, parse_yaml, Yaml obj = { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(value=\"1 + 1\", tag=\"!expr\"), } yaml_text = format_yaml(obj) print(yaml_text) # seq: # - 1 # - 2 # map: # key: value # tagged: !expr 1 + 1 parsed = parse_yaml(yaml_text) assert parsed == { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(\"1 + 1\", \"!expr\"), } Tagged nodes and mapping keys (advanced) \u00b6 Tags, custom handlers, and non-string mapping keys work without extra setup when you need them. Nodes that cannot be represented as plain Python types are wrapped in Yaml (a frozen dataclass). You will only see Yaml when: A tagged node has no matching handler; inspect .value and .tag . A mapping key is a collection or otherwise unhashable; wrapping makes it hashable while preserving any tag. See the advanced guide for details. Documentation \u00b6 YAML in 2 Minutes for a quick primer. Tags, Anchors, and Advanced YAML for handlers, mapping keys, document streams, and advanced tags. Reference for detailed signatures and examples. Contributing for building or serving the docs locally.","title":"Overview"},{"location":"#yaml12","text":"A YAML 1.2 parser/formatter for Python, implemented in Rust for speed and correctness. Built on the excellent saphyr crate. For almost every use case, yaml12 lets you work with plain builtin Python types end to end: dict , list , int , float , str , and None . Parse YAML text or files with parse_yaml() and read_yaml() . Serialize Python values with format_yaml() or write_yaml() . 100% compliance with the yaml-test-suite . Advanced YAML features (document streams, tags, complex mapping keys) are supported and round-trip cleanly when needed; see the advanced guide if needed.","title":"yaml12"},{"location":"#installation","text":"The project targets Python 3.10+ and builds via maturin (Rust toolchain required). From the repository root: python -m venv .venv source .venv/bin/activate pip install --upgrade pip pip install -e . --no-build-isolation","title":"Installation"},{"location":"#quick-start","text":"from yaml12 import parse_yaml, format_yaml yaml_text = \"\"\" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] features: tags: preserve streams: multi \"\"\" doc = parse_yaml(yaml_text) assert doc == { \"title\": \"A modern YAML parser and emitter written in Rust\", \"properties\": [\"fast\", \"correct\", \"safe\", \"simple\"], \"features\": {\"tags\": \"preserve\", \"streams\": \"multi\"}, } text = format_yaml(doc) print(text) # title: A modern YAML parser and emitter written in Rust # properties: # - fast # - correct # - safe # - simple # features: # tags: preserve # streams: multi","title":"Quick start"},{"location":"#reading-and-writing-files","text":"from yaml12 import read_yaml, write_yaml value_out = {\"alpha\": 1, \"nested\": [True, None]} write_yaml(value_out, \"my.yaml\") value_in = read_yaml(\"my.yaml\") assert value_in == value_out # Multi-document streams docs_out = [{\"foo\": 1}, {\"bar\": [2, None]}] write_yaml(docs_out, \"my-multi.yaml\", multi=True) docs_in = read_yaml(\"my-multi.yaml\", multi=True) assert docs_in == docs_out","title":"Reading and writing files"},{"location":"#tag-handlers","text":"Handlers let you opt into custom behaviour for tagged nodes while keeping the default parser strict and safe. from yaml12 import parse_yaml yaml_text = \"\"\" - !upper [rust, python] - !expr 6 * 7 \"\"\" handlers = { \"!expr\": lambda value: eval(value), \"!upper\": lambda value: [x.upper() for x in value], } doc = parse_yaml(yaml_text, handlers=handlers) assert doc == [[\"RUST\", \"PYTHON\"], 42]","title":"Tag handlers"},{"location":"#formatting-and-round-tripping","text":"from yaml12 import format_yaml, parse_yaml, Yaml obj = { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(value=\"1 + 1\", tag=\"!expr\"), } yaml_text = format_yaml(obj) print(yaml_text) # seq: # - 1 # - 2 # map: # key: value # tagged: !expr 1 + 1 parsed = parse_yaml(yaml_text) assert parsed == { \"seq\": [1, 2], \"map\": {\"key\": \"value\"}, \"tagged\": Yaml(\"1 + 1\", \"!expr\"), }","title":"Formatting and round-tripping"},{"location":"#tagged-nodes-and-mapping-keys-advanced","text":"Tags, custom handlers, and non-string mapping keys work without extra setup when you need them. Nodes that cannot be represented as plain Python types are wrapped in Yaml (a frozen dataclass). You will only see Yaml when: A tagged node has no matching handler; inspect .value and .tag . A mapping key is a collection or otherwise unhashable; wrapping makes it hashable while preserving any tag. See the advanced guide for details.","title":"Tagged nodes and mapping keys (advanced)"},{"location":"#documentation","text":"YAML in 2 Minutes for a quick primer. Tags, Anchors, and Advanced YAML for handlers, mapping keys, document streams, and advanced tags. Reference for detailed signatures and examples. Contributing for building or serving the docs locally.","title":"Documentation"},{"location":"api/","text":"API Reference (now under \"Reference\" in the nav) \u00b6 The detailed API pages now live in the Reference section: parse_yaml() and read_yaml() format_yaml() and write_yaml() Yaml is the single wrapper type for tagged nodes and unhashable mapping keys. Use plain Python types whenever possible; reach for Yaml when you need to preserve a tag or keep a list/dict hashable as a mapping key. For a quick overview of the surface area, see Reference .","title":"API Reference (now under \"Reference\" in the nav)"},{"location":"api/#api-reference-now-under-reference-in-the-nav","text":"The detailed API pages now live in the Reference section: parse_yaml() and read_yaml() format_yaml() and write_yaml() Yaml is the single wrapper type for tagged nodes and unhashable mapping keys. Use plain Python types whenever possible; reach for Yaml when you need to preserve a tag or keep a list/dict hashable as a mapping key. For a quick overview of the surface area, see Reference .","title":"API Reference (now under \"Reference\" in the nav)"},{"location":"authors/","text":"Authors and Citation \u00b6 Authors \u00b6 Tomasz Kalinowski - Author, maintainer. Posit Software, PBC - Copyright holder, funder. Citation \u00b6 Kalinowski T (2025). yaml12: Fast YAML 1.2 Parser and Formatter for Python . Python package version 0.1.0. @software{kalinowski_yaml12_python_2025, title = {yaml12: Fast YAML 1.2 Parser and Formatter for Python}, author = {Tomasz Kalinowski}, year = {2025}, version = {0.1.0}, url = {https://github.com/t-kalinowski/yaml12} }","title":"Authors and Citation"},{"location":"authors/#authors-and-citation","text":"","title":"Authors and Citation"},{"location":"authors/#authors","text":"Tomasz Kalinowski - Author, maintainer. Posit Software, PBC - Copyright holder, funder.","title":"Authors"},{"location":"authors/#citation","text":"Kalinowski T (2025). yaml12: Fast YAML 1.2 Parser and Formatter for Python . Python package version 0.1.0. @software{kalinowski_yaml12_python_2025, title = {yaml12: Fast YAML 1.2 Parser and Formatter for Python}, author = {Tomasz Kalinowski}, year = {2025}, version = {0.1.0}, url = {https://github.com/t-kalinowski/yaml12} }","title":"Citation"},{"location":"contributing/","text":"Contributing \u00b6 Build or serve the docs locally \u00b6 Install MkDocs if you have not already: python -m pip install mkdocs Then from the project root: # Build static site into ./site .venv/bin/mkdocs build # Serve with live reload at http://127.0.0.1:8000 .venv/bin/mkdocs serve","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#build-or-serve-the-docs-locally","text":"Install MkDocs if you have not already: python -m pip install mkdocs Then from the project root: # Build static site into ./site .venv/bin/mkdocs build # Serve with live reload at http://127.0.0.1:8000 .venv/bin/mkdocs serve","title":"Build or serve the docs locally"},{"location":"tags/","text":"YAML Tags, Anchors, and Advanced Features with yaml12 \u00b6 This guide picks up where the 2-minute intro leaves off. It shows what YAML tags are and how to work with them in yaml12 using handlers. Along the way it covers complex mapping keys and document streams so you can handle real-world YAML. Tags in YAML and how yaml12 handles them \u00b6 Tags annotate any YAML node with extra meaning. They always start with ! in YAML syntax and appear before the node's value; they are not part of the scalar text itself. yaml12 preserves tags as Yaml objects. The object carries value (a regular Python type) and tag (a string). Parsing a tagged scalar: from yaml12 import Yaml, parse_yaml color = parse_yaml(\"!color red\") assert isinstance(color, Yaml) and (color.tag, color.value) == (\"!color\", \"red\") Custom tags bypass the usual scalar typing; the scalar is returned as a string even if it looks like another type. assert parse_yaml(\"! true\") == Yaml(value=\"true\", tag=\"!\") assert parse_yaml(\"true\") is True Using handlers to transform tagged nodes while parsing \u00b6 parse_yaml() and read_yaml() accept handlers : a dict mapping tag strings to callables. Handlers run on any matching tagged node. For tagged scalars the handler receives the Python scalar; for tagged sequences or mappings it receives a plain list/dict. from dataclasses import dataclass from yaml12 import parse_yaml @dataclass(frozen=True) class Point: x: int y: int def point_handler(value): return Point(x=value[\"x\"], y=value[\"y\"]) doc = parse_yaml( \"vertex: !point {x: 1, y: 2}\", handlers={\"!point\": point_handler}, ) assert doc[\"vertex\"] == Point(1, 2) Handlers apply to both values and keys, including non-specific ! tags if you register \"!\" . If a handler raises an exception, it propagates unchanged to make debugging easy. Any tag without a matching handler stays as a Yaml object. Handlers without matching tags are simply unused. Post-process tags yourself \u00b6 You can also parse without handlers and walk the result yourself. For example, processing !expr scalars manually: from yaml12 import Yaml, parse_yaml def eval_yaml_expr_nodes(obj): if isinstance(obj, Yaml): if obj.tag == \"!expr\": return eval(str(obj.value)) return Yaml(eval_yaml_expr_nodes(obj.value), obj.tag) if isinstance(obj, list): return [eval_yaml_expr_nodes(item) for item in obj] if isinstance(obj, dict): return {eval_yaml_expr_nodes(k): eval_yaml_expr_nodes(v) for k, v in obj.items()} return obj raw = parse_yaml(\"!expr 1 + 1\") assert isinstance(raw, Yaml) and eval_yaml_expr_nodes(raw) == 2 Mappings revisited: non-string keys and Yaml \u00b6 YAML mapping keys do not have to be plain strings; any node can be a key. For example, this is valid even though the key is a boolean: true: true Parsed with yaml12 , unhashable or tagged keys become Yaml so they can live in a Python dict while preserving equality and hashing by structure: parsed = parse_yaml(\"true: true\") key = next(iter(parsed)) assert key is True and parsed[key] is True and not isinstance(key, Yaml) Complex keys use the explicit mapping-key indicator ? : ? [a, b] : tuple ? {x: 1, y: 2} : map-key Becomes: parsed = parse_yaml(...above yaml...) keys = list(parsed) assert all(isinstance(k, Yaml) for k in keys) and keys[0].value == [\"a\", \"b\"] and keys[1].value == {\"x\": 1, \"y\": 2} Tagged mapping keys \u00b6 Handlers run on keys too, so a handler can turn tagged keys into friendly Python keys before they are wrapped. handlers = {\"!upper\": str.upper} result = parse_yaml(\"!upper key: value\", handlers=handlers) assert result == {\"KEY\": \"value\"} If you anticipate tagged mapping keys that you want to process yourself, walk the Yaml keys alongside the values and unwrap them as needed. Document streams and markers \u00b6 Most YAML files contain a single document. YAML also supports document streams: multiple documents separated by --- and optionally closed by ... . Reading multiple documents \u00b6 parse_yaml() and read_yaml() default to multi=False , returning only the first document. When multi=True , all documents are returned as a list. doc_stream = \"\"\" --- doc 1 --- doc 2 \"\"\" parsed_first = parse_yaml(doc_stream) parsed_all = parse_yaml(doc_stream, multi=True) assert (parsed_first, parsed_all) == (\"doc 1\", [\"doc 1\", \"doc 2\"]) Writing multiple documents \u00b6 write_yaml() and format_yaml() default to a single document. With multi=True , the value must be a sequence of documents and the output uses --- between documents and ... after the final one. For single documents, write_yaml() always wraps the body with --- and a final ... , while format_yaml() returns just the body. from yaml12 import format_yaml, write_yaml docs = [\"first\", \"second\"] text = format_yaml(docs, multi=True) assert text.startswith(\"---\") and text.rstrip().endswith(\"...\") write_yaml(docs, path=\"out.yml\", multi=True) When multi=False , parsing stops after the first document, even if later content is not valid YAML. That makes it easy to extract front matter from files that mix YAML with other text (like Markdown). rmd_lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] frontmatter = parse_yaml(rmd_lines) assert frontmatter == {\"title\": \"Front matter only\", \"params\": {\"answer\": 42}} Writing YAML with tags \u00b6 Attach Yaml to values before calling format_yaml() or write_yaml() to emit a tag. from yaml12 import Yaml, write_yaml tagged = Yaml(\"1 + x\", \"!expr\") write_yaml(tagged) # stdout: # --- # !expr 1 + x # ... Tagged collections or mapping keys work the same way: from yaml12 import Yaml, format_yaml, parse_yaml mapping = { \"tagged_value\": Yaml([\"a\", \"b\"], \"!pair\"), Yaml(\"tagged-key\", \"!k\"): \"v\", } encoded = format_yaml(mapping) reparsed = parse_yaml(encoded) value = reparsed[\"tagged_value\"] assert isinstance(value, Yaml) and value.tag == \"!pair\" and value.value == [\"a\", \"b\"] key = next(k for k in reparsed if isinstance(k, Yaml)) assert key.tag == \"!k\" and key.value == \"tagged-key\" and reparsed[key] == \"v\" Serializing custom Python objects \u00b6 You can opt into rich types by tagging your own objects on emit and supplying a handler on parse. Here is a round-trip for a dataclass: from dataclasses import dataclass, asdict from yaml12 import Yaml, format_yaml, parse_yaml @dataclass class Server: name: str host: str port: int def encode_server(server: Server) -> Yaml: return Yaml(asdict(server), \"!server\") def decode_server(value): return Server(**value) servers = [Server(\"api\", \"api.example.com\", 8000), Server(\"db\", \"db.local\", 5432)] yaml_text = format_yaml([encode_server(s) for s in servers]) round_tripped = parse_yaml(yaml_text, handlers={\"!server\": decode_server}) assert round_tripped == servers By keeping the on-disk representation a plain mapping plus tag, you get a stable YAML format while still round-tripping your Python types losslessly. Anchors \u00b6 Anchors ( &id ) name a node; aliases ( *id ) copy it. yaml12 resolves aliases before returning Python objects. from yaml12 import parse_yaml parsed = parse_yaml(\"\"\" recycle-me: &anchor-name a: b c: d recycled: - *anchor-name - *anchor-name \"\"\") first, second = parsed[\"recycled\"] assert first[\"a\"] == \"b\" and second[\"c\"] == \"d\" (Very) advanced tags \u00b6 Tag directives ( %TAG ) \u00b6 YAML lets you declare tag handles at the top of a document. The syntax is %TAG !<name>! <handle> and it applies to the rest of the document. text = \"\"\" %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo \"\"\" parsed = parse_yaml(text) assert parsed[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" You can also declare a global tag prefix, which expands a bare ! : text = \"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo \"\"\" assert parse_yaml(text)[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" Tag URIs \u00b6 To bypass handle resolution, use !<...> with a valid URI-like string: parsed = parse_yaml(\"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo \"\"\") assert parsed[\"item\"].tag == \"gizmo\" Core schema tags \u00b6 Tags beginning with !! resolve against the YAML core schema handle ( tag:yaml.org,2002: ). Scalar core tags ( !!str , !!int , !!float , !!bool , !!null , !!seq , !!map ) add no information when emitting and are normalized to plain Python values. Informative core tags ( !!timestamp , !!binary , !!set , !!omap , !!pairs ) stay tagged so you can decide how to handle them. from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10-05:00 - !!binary UiBpcyBBd2Vzb21l \"\"\" parsed = parse_yaml(yaml_text) assert all(isinstance(item, Yaml) for item in parsed) and ( parsed[0].tag, parsed[2].tag, ) == (\"tag:yaml.org,2002:timestamp\", \"tag:yaml.org,2002:binary\") Handlers can convert these to richer Python types: import base64 from datetime import datetime, timezone from yaml12 import parse_yaml def ts_handler(value): return datetime.fromisoformat(str(value).replace(\"Z\", \"+00:00\")).replace(tzinfo=timezone.utc) def binary_handler(value): return base64.b64decode(str(value)) converted = parse_yaml( yaml_text, handlers={ \"tag:yaml.org,2002:timestamp\": ts_handler, \"tag:yaml.org,2002:binary\": binary_handler, }, ) assert isinstance(converted[0], datetime) and isinstance(converted[2], (bytes, bytearray))","title":"Tags, Anchors, and Advanced YAML"},{"location":"tags/#yaml-tags-anchors-and-advanced-features-with-yaml12","text":"This guide picks up where the 2-minute intro leaves off. It shows what YAML tags are and how to work with them in yaml12 using handlers. Along the way it covers complex mapping keys and document streams so you can handle real-world YAML.","title":"YAML Tags, Anchors, and Advanced Features with yaml12"},{"location":"tags/#tags-in-yaml-and-how-yaml12-handles-them","text":"Tags annotate any YAML node with extra meaning. They always start with ! in YAML syntax and appear before the node's value; they are not part of the scalar text itself. yaml12 preserves tags as Yaml objects. The object carries value (a regular Python type) and tag (a string). Parsing a tagged scalar: from yaml12 import Yaml, parse_yaml color = parse_yaml(\"!color red\") assert isinstance(color, Yaml) and (color.tag, color.value) == (\"!color\", \"red\") Custom tags bypass the usual scalar typing; the scalar is returned as a string even if it looks like another type. assert parse_yaml(\"! true\") == Yaml(value=\"true\", tag=\"!\") assert parse_yaml(\"true\") is True","title":"Tags in YAML and how yaml12 handles them"},{"location":"tags/#using-handlers-to-transform-tagged-nodes-while-parsing","text":"parse_yaml() and read_yaml() accept handlers : a dict mapping tag strings to callables. Handlers run on any matching tagged node. For tagged scalars the handler receives the Python scalar; for tagged sequences or mappings it receives a plain list/dict. from dataclasses import dataclass from yaml12 import parse_yaml @dataclass(frozen=True) class Point: x: int y: int def point_handler(value): return Point(x=value[\"x\"], y=value[\"y\"]) doc = parse_yaml( \"vertex: !point {x: 1, y: 2}\", handlers={\"!point\": point_handler}, ) assert doc[\"vertex\"] == Point(1, 2) Handlers apply to both values and keys, including non-specific ! tags if you register \"!\" . If a handler raises an exception, it propagates unchanged to make debugging easy. Any tag without a matching handler stays as a Yaml object. Handlers without matching tags are simply unused.","title":"Using handlers to transform tagged nodes while parsing"},{"location":"tags/#post-process-tags-yourself","text":"You can also parse without handlers and walk the result yourself. For example, processing !expr scalars manually: from yaml12 import Yaml, parse_yaml def eval_yaml_expr_nodes(obj): if isinstance(obj, Yaml): if obj.tag == \"!expr\": return eval(str(obj.value)) return Yaml(eval_yaml_expr_nodes(obj.value), obj.tag) if isinstance(obj, list): return [eval_yaml_expr_nodes(item) for item in obj] if isinstance(obj, dict): return {eval_yaml_expr_nodes(k): eval_yaml_expr_nodes(v) for k, v in obj.items()} return obj raw = parse_yaml(\"!expr 1 + 1\") assert isinstance(raw, Yaml) and eval_yaml_expr_nodes(raw) == 2","title":"Post-process tags yourself"},{"location":"tags/#mappings-revisited-non-string-keys-and-yaml","text":"YAML mapping keys do not have to be plain strings; any node can be a key. For example, this is valid even though the key is a boolean: true: true Parsed with yaml12 , unhashable or tagged keys become Yaml so they can live in a Python dict while preserving equality and hashing by structure: parsed = parse_yaml(\"true: true\") key = next(iter(parsed)) assert key is True and parsed[key] is True and not isinstance(key, Yaml) Complex keys use the explicit mapping-key indicator ? : ? [a, b] : tuple ? {x: 1, y: 2} : map-key Becomes: parsed = parse_yaml(...above yaml...) keys = list(parsed) assert all(isinstance(k, Yaml) for k in keys) and keys[0].value == [\"a\", \"b\"] and keys[1].value == {\"x\": 1, \"y\": 2}","title":"Mappings revisited: non-string keys and Yaml"},{"location":"tags/#tagged-mapping-keys","text":"Handlers run on keys too, so a handler can turn tagged keys into friendly Python keys before they are wrapped. handlers = {\"!upper\": str.upper} result = parse_yaml(\"!upper key: value\", handlers=handlers) assert result == {\"KEY\": \"value\"} If you anticipate tagged mapping keys that you want to process yourself, walk the Yaml keys alongside the values and unwrap them as needed.","title":"Tagged mapping keys"},{"location":"tags/#document-streams-and-markers","text":"Most YAML files contain a single document. YAML also supports document streams: multiple documents separated by --- and optionally closed by ... .","title":"Document streams and markers"},{"location":"tags/#reading-multiple-documents","text":"parse_yaml() and read_yaml() default to multi=False , returning only the first document. When multi=True , all documents are returned as a list. doc_stream = \"\"\" --- doc 1 --- doc 2 \"\"\" parsed_first = parse_yaml(doc_stream) parsed_all = parse_yaml(doc_stream, multi=True) assert (parsed_first, parsed_all) == (\"doc 1\", [\"doc 1\", \"doc 2\"])","title":"Reading multiple documents"},{"location":"tags/#writing-multiple-documents","text":"write_yaml() and format_yaml() default to a single document. With multi=True , the value must be a sequence of documents and the output uses --- between documents and ... after the final one. For single documents, write_yaml() always wraps the body with --- and a final ... , while format_yaml() returns just the body. from yaml12 import format_yaml, write_yaml docs = [\"first\", \"second\"] text = format_yaml(docs, multi=True) assert text.startswith(\"---\") and text.rstrip().endswith(\"...\") write_yaml(docs, path=\"out.yml\", multi=True) When multi=False , parsing stops after the first document, even if later content is not valid YAML. That makes it easy to extract front matter from files that mix YAML with other text (like Markdown). rmd_lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] frontmatter = parse_yaml(rmd_lines) assert frontmatter == {\"title\": \"Front matter only\", \"params\": {\"answer\": 42}}","title":"Writing multiple documents"},{"location":"tags/#writing-yaml-with-tags","text":"Attach Yaml to values before calling format_yaml() or write_yaml() to emit a tag. from yaml12 import Yaml, write_yaml tagged = Yaml(\"1 + x\", \"!expr\") write_yaml(tagged) # stdout: # --- # !expr 1 + x # ... Tagged collections or mapping keys work the same way: from yaml12 import Yaml, format_yaml, parse_yaml mapping = { \"tagged_value\": Yaml([\"a\", \"b\"], \"!pair\"), Yaml(\"tagged-key\", \"!k\"): \"v\", } encoded = format_yaml(mapping) reparsed = parse_yaml(encoded) value = reparsed[\"tagged_value\"] assert isinstance(value, Yaml) and value.tag == \"!pair\" and value.value == [\"a\", \"b\"] key = next(k for k in reparsed if isinstance(k, Yaml)) assert key.tag == \"!k\" and key.value == \"tagged-key\" and reparsed[key] == \"v\"","title":"Writing YAML with tags"},{"location":"tags/#serializing-custom-python-objects","text":"You can opt into rich types by tagging your own objects on emit and supplying a handler on parse. Here is a round-trip for a dataclass: from dataclasses import dataclass, asdict from yaml12 import Yaml, format_yaml, parse_yaml @dataclass class Server: name: str host: str port: int def encode_server(server: Server) -> Yaml: return Yaml(asdict(server), \"!server\") def decode_server(value): return Server(**value) servers = [Server(\"api\", \"api.example.com\", 8000), Server(\"db\", \"db.local\", 5432)] yaml_text = format_yaml([encode_server(s) for s in servers]) round_tripped = parse_yaml(yaml_text, handlers={\"!server\": decode_server}) assert round_tripped == servers By keeping the on-disk representation a plain mapping plus tag, you get a stable YAML format while still round-tripping your Python types losslessly.","title":"Serializing custom Python objects"},{"location":"tags/#anchors","text":"Anchors ( &id ) name a node; aliases ( *id ) copy it. yaml12 resolves aliases before returning Python objects. from yaml12 import parse_yaml parsed = parse_yaml(\"\"\" recycle-me: &anchor-name a: b c: d recycled: - *anchor-name - *anchor-name \"\"\") first, second = parsed[\"recycled\"] assert first[\"a\"] == \"b\" and second[\"c\"] == \"d\"","title":"Anchors"},{"location":"tags/#very-advanced-tags","text":"","title":"(Very) advanced tags"},{"location":"tags/#tag-directives-tag","text":"YAML lets you declare tag handles at the top of a document. The syntax is %TAG !<name>! <handle> and it applies to the rest of the document. text = \"\"\" %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo \"\"\" parsed = parse_yaml(text) assert parsed[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\" You can also declare a global tag prefix, which expands a bare ! : text = \"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo \"\"\" assert parse_yaml(text)[\"item\"].tag == \"tag:example.com,2024:widgets/gizmo\"","title":"Tag directives (%TAG)"},{"location":"tags/#tag-uris","text":"To bypass handle resolution, use !<...> with a valid URI-like string: parsed = parse_yaml(\"\"\" %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo \"\"\") assert parsed[\"item\"].tag == \"gizmo\"","title":"Tag URIs"},{"location":"tags/#core-schema-tags","text":"Tags beginning with !! resolve against the YAML core schema handle ( tag:yaml.org,2002: ). Scalar core tags ( !!str , !!int , !!float , !!bool , !!null , !!seq , !!map ) add no information when emitting and are normalized to plain Python values. Informative core tags ( !!timestamp , !!binary , !!set , !!omap , !!pairs ) stay tagged so you can decide how to handle them. from yaml12 import Yaml, parse_yaml yaml_text = \"\"\" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10-05:00 - !!binary UiBpcyBBd2Vzb21l \"\"\" parsed = parse_yaml(yaml_text) assert all(isinstance(item, Yaml) for item in parsed) and ( parsed[0].tag, parsed[2].tag, ) == (\"tag:yaml.org,2002:timestamp\", \"tag:yaml.org,2002:binary\") Handlers can convert these to richer Python types: import base64 from datetime import datetime, timezone from yaml12 import parse_yaml def ts_handler(value): return datetime.fromisoformat(str(value).replace(\"Z\", \"+00:00\")).replace(tzinfo=timezone.utc) def binary_handler(value): return base64.b64decode(str(value)) converted = parse_yaml( yaml_text, handlers={ \"tag:yaml.org,2002:timestamp\": ts_handler, \"tag:yaml.org,2002:binary\": binary_handler, }, ) assert isinstance(converted[0], datetime) and isinstance(converted[2], (bytes, bytearray))","title":"Core schema tags"},{"location":"usage/","text":"YAML in 2 Minutes: A Gentle Introduction for Python Users \u00b6 from yaml12 import parse_yaml YAML is a human-friendly data serialization format. Think of it as \"JSON with comments and nicer multiline strings.\" yaml12 follows the modern YAML 1.2 spec (no surprising 1.1-era conversions). YAML has three building blocks: scalars (single values), sequences (ordered collections), and mappings (key/value pairs). JSON is a subset of YAML 1.2, so all valid JSON is also valid YAML and parses the same way. A first example \u00b6 title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. first_example_text = \"\"\" title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. \"\"\" doc = parse_yaml(first_example_text) assert doc == { \"title\": \"A Modern YAML parser written in Rust\", \"properties\": [\"correct\", \"safe\", \"fast\", \"simple\"], \"score\": 9.5, \"categories\": [\"yaml\", \"python\", \"example\"], \"settings\": { \"note\": \"This is a folded block that turns line breaks into spaces.\\n\", \"note_literal\": \"This is a literal block\\nthat keeps\\nline breaks.\\n\", }, } Collections \u00b6 There are two collection types: sequences and mappings . Sequences: YAML's ordered collections \u00b6 Each item begins with - at the parent indent. - cat - dog parses to [\"cat\", \"dog\"] . JSON-style arrays work too: [cat, dog] Anything belonging to one of the sequence entries is indented at least one space past the dash: - name: cat toys: [string, box] - name: dog toys: [ball, bone] parses to: [ {\"name\": \"cat\", \"toys\": [\"string\", \"box\"]}, {\"name\": \"dog\", \"toys\": [\"ball\", \"bone\"]}, ] Mappings: key/value pairs \u00b6 Mappings are sets of key: value pairs at the same indent: foo: 1 bar: true parses to {\"foo\": 1, \"bar\": True} . A key at its indent owns anything indented more: settings: debug: true max_items: 3 parses to {\"settings\": {\"debug\": True, \"max_items\": 3}} . JSON-style objects work too: {a: true} -> {\"a\": True} Scalars \u00b6 Everything that is not a collection is a scalar. Scalars can be block, quoted, or plain. Block scalars \u00b6 | starts a literal block that keeps newlines; > starts a folded block that joins lines with spaces (except blank/indented lines keep breaks). Block scalars always become strings. | hello world -> \"hello\\nworld\\n\" > hello world -> \"hello world\\n\" Quoted scalars \u00b6 Quoted scalars always become strings. Double quotes interpret escapes ( \\n , \\t , \\\\ , \\\" ). Single quotes are literal and do not interpret escapes, except for '' which is parsed as a single ' . [\"line\\nbreak\", \"quote: \\\"here\\\"\"] -> [\"line\\nbreak\", 'quote: \"here\"'] ['line\\nbreak', 'quote: ''here'''] -> [\"line\\\\nbreak\", \"quote: 'here'\"] Plain (unquoted) scalars \u00b6 Plain nodes can resolve to one of five types: string, int, float, bool, or null. true / false -> True / False null , ~ , or empty -> None numbers: signed, decimal, scientific, hex ( 0x ), octal ( 0o ), .inf , .nan -> int or float everything else stays a string ( yes , no , on , off and other aliases remain strings in YAML 1.2) [true, 123, 4.5e2, 0x10, .inf, yes] -> [True, 123, 450.0, 16, float(\"inf\"), \"yes\"] End-to-end example \u00b6 doc: pets: - cat - dog numbers: [1, 2.5, 0x10, .inf, null] integers: [1, 2, 3, 0x10, null] flags: {enabled: true, label: on} literal: | hello world folded: > hello world quoted: - \"line\\nbreak\" - 'quote: ''here''' plain: [yes, no] mixed: [won't simplify, 123, true] Python result: { \"doc\": { \"pets\": [\"cat\", \"dog\"], \"numbers\": [1, 2.5, 16, float(\"inf\"), None], \"integers\": [1, 2, 3, 16, None], \"flags\": {\"enabled\": True, \"label\": \"on\"}, \"literal\": \"hello\\nworld\\n\", \"folded\": \"hello world\\n\", \"quoted\": [\"line\\nbreak\", \"quote: 'here'\"], \"plain\": [\"yes\", \"no\"], \"mixed\": [\"won't simplify\", 123, True], } } Quick notes \u00b6 Indentation defines structure for collections. Sibling elements share an indent; children are indented more. YAML 1.2 forbids tabs; use spaces. All JSON is valid YAML. Sequences stay Python lists; there is no vector \"simplification.\" Block scalars ( | , > ) always produce strings. Booleans are only true / false ; null maps to None . Numbers can be signed, scientific, hex ( 0x ), octal ( 0o ), .inf , and .nan . These essentials cover most YAML you'll see. For tags, anchors, and non-string mapping keys, see the advanced guide.","title":"YAML in 2 Minutes"},{"location":"usage/#yaml-in-2-minutes-a-gentle-introduction-for-python-users","text":"from yaml12 import parse_yaml YAML is a human-friendly data serialization format. Think of it as \"JSON with comments and nicer multiline strings.\" yaml12 follows the modern YAML 1.2 spec (no surprising 1.1-era conversions). YAML has three building blocks: scalars (single values), sequences (ordered collections), and mappings (key/value pairs). JSON is a subset of YAML 1.2, so all valid JSON is also valid YAML and parses the same way.","title":"YAML in 2 Minutes: A Gentle Introduction for Python Users"},{"location":"usage/#a-first-example","text":"title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. first_example_text = \"\"\" title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories: - yaml - python - example settings: note: > This is a folded block that turns line breaks into spaces. note_literal: | This is a literal block that keeps line breaks. \"\"\" doc = parse_yaml(first_example_text) assert doc == { \"title\": \"A Modern YAML parser written in Rust\", \"properties\": [\"correct\", \"safe\", \"fast\", \"simple\"], \"score\": 9.5, \"categories\": [\"yaml\", \"python\", \"example\"], \"settings\": { \"note\": \"This is a folded block that turns line breaks into spaces.\\n\", \"note_literal\": \"This is a literal block\\nthat keeps\\nline breaks.\\n\", }, }","title":"A first example"},{"location":"usage/#collections","text":"There are two collection types: sequences and mappings .","title":"Collections"},{"location":"usage/#sequences-yamls-ordered-collections","text":"Each item begins with - at the parent indent. - cat - dog parses to [\"cat\", \"dog\"] . JSON-style arrays work too: [cat, dog] Anything belonging to one of the sequence entries is indented at least one space past the dash: - name: cat toys: [string, box] - name: dog toys: [ball, bone] parses to: [ {\"name\": \"cat\", \"toys\": [\"string\", \"box\"]}, {\"name\": \"dog\", \"toys\": [\"ball\", \"bone\"]}, ]","title":"Sequences: YAML's ordered collections"},{"location":"usage/#mappings-keyvalue-pairs","text":"Mappings are sets of key: value pairs at the same indent: foo: 1 bar: true parses to {\"foo\": 1, \"bar\": True} . A key at its indent owns anything indented more: settings: debug: true max_items: 3 parses to {\"settings\": {\"debug\": True, \"max_items\": 3}} . JSON-style objects work too: {a: true} -> {\"a\": True}","title":"Mappings: key/value pairs"},{"location":"usage/#scalars","text":"Everything that is not a collection is a scalar. Scalars can be block, quoted, or plain.","title":"Scalars"},{"location":"usage/#block-scalars","text":"| starts a literal block that keeps newlines; > starts a folded block that joins lines with spaces (except blank/indented lines keep breaks). Block scalars always become strings. | hello world -> \"hello\\nworld\\n\" > hello world -> \"hello world\\n\"","title":"Block scalars"},{"location":"usage/#quoted-scalars","text":"Quoted scalars always become strings. Double quotes interpret escapes ( \\n , \\t , \\\\ , \\\" ). Single quotes are literal and do not interpret escapes, except for '' which is parsed as a single ' . [\"line\\nbreak\", \"quote: \\\"here\\\"\"] -> [\"line\\nbreak\", 'quote: \"here\"'] ['line\\nbreak', 'quote: ''here'''] -> [\"line\\\\nbreak\", \"quote: 'here'\"]","title":"Quoted scalars"},{"location":"usage/#plain-unquoted-scalars","text":"Plain nodes can resolve to one of five types: string, int, float, bool, or null. true / false -> True / False null , ~ , or empty -> None numbers: signed, decimal, scientific, hex ( 0x ), octal ( 0o ), .inf , .nan -> int or float everything else stays a string ( yes , no , on , off and other aliases remain strings in YAML 1.2) [true, 123, 4.5e2, 0x10, .inf, yes] -> [True, 123, 450.0, 16, float(\"inf\"), \"yes\"]","title":"Plain (unquoted) scalars"},{"location":"usage/#end-to-end-example","text":"doc: pets: - cat - dog numbers: [1, 2.5, 0x10, .inf, null] integers: [1, 2, 3, 0x10, null] flags: {enabled: true, label: on} literal: | hello world folded: > hello world quoted: - \"line\\nbreak\" - 'quote: ''here''' plain: [yes, no] mixed: [won't simplify, 123, true] Python result: { \"doc\": { \"pets\": [\"cat\", \"dog\"], \"numbers\": [1, 2.5, 16, float(\"inf\"), None], \"integers\": [1, 2, 3, 16, None], \"flags\": {\"enabled\": True, \"label\": \"on\"}, \"literal\": \"hello\\nworld\\n\", \"folded\": \"hello world\\n\", \"quoted\": [\"line\\nbreak\", \"quote: 'here'\"], \"plain\": [\"yes\", \"no\"], \"mixed\": [\"won't simplify\", 123, True], } }","title":"End-to-end example"},{"location":"usage/#quick-notes","text":"Indentation defines structure for collections. Sibling elements share an indent; children are indented more. YAML 1.2 forbids tabs; use spaces. All JSON is valid YAML. Sequences stay Python lists; there is no vector \"simplification.\" Block scalars ( | , > ) always produce strings. Booleans are only true / false ; null maps to None . Numbers can be signed, scientific, hex ( 0x ), octal ( 0o ), .inf , and .nan . These essentials cover most YAML you'll see. For tags, anchors, and non-string mapping keys, see the advanced guide.","title":"Quick notes"},{"location":"reference/","text":"Reference \u00b6 All functions \u00b6 parse_yaml() and read_yaml() : Parse YAML 1.2 text or files into Python structures. format_yaml() and write_yaml() : Format or write Python objects as YAML 1.2.","title":"Overview"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#all-functions","text":"parse_yaml() and read_yaml() : Parse YAML 1.2 text or files into Python structures. format_yaml() and write_yaml() : Format or write Python objects as YAML 1.2.","title":"All functions"},{"location":"reference/format_yaml/","text":"Format or write Python objects as YAML 1.2. \u00b6 format_yaml() returns YAML as a string. write_yaml() writes a YAML stream to a file or writer. Both functions honor Yaml tags on values and mapping keys; scalar core tags ( !!str , !!int , !!bool , !!float , !!null , !!seq , !!map ) are dropped on emit because they add no extra information. Usage \u00b6 format_yaml(value, multi=False) write_yaml(value, path=None, multi=False) Arguments \u00b6 value: Any combination of Python scalars, lists, and dicts; tagged values or mapping keys can be wrapped in Yaml . When multi=True , value must be a sequence of documents. multi: When True , treat value as a list of YAML documents and encode a stream separated by --- and terminated with ... . path: Destination path ( str or os.PathLike ) or writable object with .write() . When None , write to stdout. Writers are tried with text first, then retried as bytes if text writes fail. Returns \u00b6 format_yaml() returns a str containing YAML (ending with ...\\n for multi-document output); single-document output omits the leading --- marker and trailing newline. write_yaml() returns None . Examples \u00b6 from pathlib import Path from yaml12 import Yaml, format_yaml, write_yaml format_yaml({\"foo\": 1, \"bar\": [True, None]}) # 'foo: 1\\nbar:\\n - true\\n - ~' docs = [{\"foo\": 1}, {\"bar\": [2, None]}] format_yaml(docs, multi=True) # '---\\nfoo: 1\\n---\\nbar:\\n - 2\\n - ~\\n...\\n' tagged = Yaml(\"1 + 1\", \"!expr\") format_yaml(tagged) # '!expr 1 + 1' path = Path(\"example.yaml\") write_yaml({\"alpha\": 1}, path) assert path.read_text(encoding=\"utf-8\") == f\"---\\n{format_yaml({'alpha': 1})}\\n...\\n\"","title":"format_yaml() and write_yaml()"},{"location":"reference/format_yaml/#format-or-write-python-objects-as-yaml-12","text":"format_yaml() returns YAML as a string. write_yaml() writes a YAML stream to a file or writer. Both functions honor Yaml tags on values and mapping keys; scalar core tags ( !!str , !!int , !!bool , !!float , !!null , !!seq , !!map ) are dropped on emit because they add no extra information.","title":"Format or write Python objects as YAML 1.2."},{"location":"reference/format_yaml/#usage","text":"format_yaml(value, multi=False) write_yaml(value, path=None, multi=False)","title":"Usage"},{"location":"reference/format_yaml/#arguments","text":"value: Any combination of Python scalars, lists, and dicts; tagged values or mapping keys can be wrapped in Yaml . When multi=True , value must be a sequence of documents. multi: When True , treat value as a list of YAML documents and encode a stream separated by --- and terminated with ... . path: Destination path ( str or os.PathLike ) or writable object with .write() . When None , write to stdout. Writers are tried with text first, then retried as bytes if text writes fail.","title":"Arguments"},{"location":"reference/format_yaml/#returns","text":"format_yaml() returns a str containing YAML (ending with ...\\n for multi-document output); single-document output omits the leading --- marker and trailing newline. write_yaml() returns None .","title":"Returns"},{"location":"reference/format_yaml/#examples","text":"from pathlib import Path from yaml12 import Yaml, format_yaml, write_yaml format_yaml({\"foo\": 1, \"bar\": [True, None]}) # 'foo: 1\\nbar:\\n - true\\n - ~' docs = [{\"foo\": 1}, {\"bar\": [2, None]}] format_yaml(docs, multi=True) # '---\\nfoo: 1\\n---\\nbar:\\n - 2\\n - ~\\n...\\n' tagged = Yaml(\"1 + 1\", \"!expr\") format_yaml(tagged) # '!expr 1 + 1' path = Path(\"example.yaml\") write_yaml({\"alpha\": 1}, path) assert path.read_text(encoding=\"utf-8\") == f\"---\\n{format_yaml({'alpha': 1})}\\n...\\n\"","title":"Examples"},{"location":"reference/parse_yaml/","text":"Parse YAML 1.2 text or files into Python objects. \u00b6 parse_yaml() takes YAML text; read_yaml() reads from a path or a streaming reader. Usage \u00b6 parse_yaml(text, multi=False, handlers=None) read_yaml(path, multi=False, handlers=None) Arguments \u00b6 text: str or sequence of str ; sequence items are joined with \"\\n\" . When empty, returns None (or [] when multi=True ). path: str , os.PathLike , or readable object yielding str or UTF-8 bytes . multi: When True , parse the whole stream and return a list of documents; when False , stop after the first document. handlers: Optional dict[str, Callable] keyed by YAML tag strings; matching handlers transform tagged values and keys. Exceptions from handlers propagate unchanged. Returns \u00b6 When multi=False , the first document or None for empty input. When multi=True , a list of all documents. Tagged nodes without a matching handler (including informative core tags such as !!timestamp or !!binary ) become Yaml objects. Unhashable mapping keys are wrapped in Yaml so they remain hashable. Examples \u00b6 from yaml12 import parse_yaml parse_yaml(\"foo: [1, 2, 3]\") # {'foo': [1, 2, 3]} stream = \"\"\" --- first: 1 --- second: 2 \"\"\" parse_yaml(stream) # returns {'first': 1} parse_yaml(stream, multi=True) # returns [{'first': 1}, {'second': 2}] handlers = {\"!upper\": lambda value: str(value).upper()} parse_yaml(\"!upper key: !upper value\", handlers=handlers) # {'KEY': 'VALUE'} lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] parse_yaml(lines) # {'title': 'Front matter only', 'params': {'answer': 42}}","title":"parse_yaml() and read_yaml()"},{"location":"reference/parse_yaml/#parse-yaml-12-text-or-files-into-python-objects","text":"parse_yaml() takes YAML text; read_yaml() reads from a path or a streaming reader.","title":"Parse YAML 1.2 text or files into Python objects."},{"location":"reference/parse_yaml/#usage","text":"parse_yaml(text, multi=False, handlers=None) read_yaml(path, multi=False, handlers=None)","title":"Usage"},{"location":"reference/parse_yaml/#arguments","text":"text: str or sequence of str ; sequence items are joined with \"\\n\" . When empty, returns None (or [] when multi=True ). path: str , os.PathLike , or readable object yielding str or UTF-8 bytes . multi: When True , parse the whole stream and return a list of documents; when False , stop after the first document. handlers: Optional dict[str, Callable] keyed by YAML tag strings; matching handlers transform tagged values and keys. Exceptions from handlers propagate unchanged.","title":"Arguments"},{"location":"reference/parse_yaml/#returns","text":"When multi=False , the first document or None for empty input. When multi=True , a list of all documents. Tagged nodes without a matching handler (including informative core tags such as !!timestamp or !!binary ) become Yaml objects. Unhashable mapping keys are wrapped in Yaml so they remain hashable.","title":"Returns"},{"location":"reference/parse_yaml/#examples","text":"from yaml12 import parse_yaml parse_yaml(\"foo: [1, 2, 3]\") # {'foo': [1, 2, 3]} stream = \"\"\" --- first: 1 --- second: 2 \"\"\" parse_yaml(stream) # returns {'first': 1} parse_yaml(stream, multi=True) # returns [{'first': 1}, {'second': 2}] handlers = {\"!upper\": lambda value: str(value).upper()} parse_yaml(\"!upper key: !upper value\", handlers=handlers) # {'KEY': 'VALUE'} lines = [ \"---\", \"title: Front matter only\", \"params:\", \" answer: 42\", \"---\", \"# Body that is not YAML\", ] parse_yaml(lines) # {'title': 'Front matter only', 'params': {'answer': 42}}","title":"Examples"}]}